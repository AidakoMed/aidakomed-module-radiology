/* ****************************************************************************
 * Copyright (C) 2007 Hx Technologies, Inc.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 * 
 * $Id: ImageConverter.java,v 1.1.1.1 2007/10/18 15:58:37 kpearce Exp $
 * Last Revised By   : $Author: kpearce $
 * Last Checked In   : $Date: 2007/10/18 15:58:37 $
 * Last Version      : $Revision: 1.1.1.1 $
 *
 * Original Author   : Rafael Chargel
 * Origin            : Hx Technologies Inc.
 *
 *****************************************************************************/
package com.hxti.xebra.util;

import java.awt.image.BufferedImage;

import java.io.BufferedOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.OutputStream;

import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import javax.imageio.ImageIO;
import javax.imageio.ImageWriteParam;
import javax.imageio.ImageWriter;

import javax.imageio.stream.ImageOutputStream;

import javax.media.jai.JAI;
import javax.media.jai.ParameterBlockJAI;

import javax.servlet.http.HttpServletResponse;

import org.apache.log4j.Logger;

import com.hxti.dicom.exception.WADOException;
import com.hxti.dicom.util.ErrorMessages;
import com.hxti.dicom.util.ModalityJ2KParams;

import com.hxti.pixelmed.web.WadoRequest;
import com.hxti.xebra.com.AbstractServlet;
import com.hxti.xebra.com.wado.WADORequestHandler;
import com.sun.media.imageio.plugins.jpeg2000.J2KImageWriteParam;

/**
 * Converts any DICOM file into a usable image compression format. This class
 * supports the following formats:
 * 
 * <ul type="square">
 * <li><code>JPEG</code></li>
 * <li><code>JPEG2000</code></li>
 * <li><code>TIFF</code></li>
 * <li><code>BMP</code></li>
 * <li><code>PNG</code></li>
 * </ul>
 * 
 * <p>
 * Because the <code>GIF</code> format is a proprietary format, this
 * application does not currently (nor are there any intentions of) supporting
 * this format.
 * </p>
 * 
 * <p>
 * <b>Note:</b> This class also takes advantage of the <code>PixelMed</code>
 * libraries which are not included in this project's folders. The
 * <code>PixelMed</code> library, and it's dependancies, are available from
 * the <a target="_blank" href="http://www.pixelmed.com/">PixelMed web site</a>.
 * </p>
 * 
 * @author Rafael Chargel
 * @version $Revision: 1.1.1.1 $
 */
public class ImageConverter
{
	public static final String	JPEG		= "image/jpeg";
	public static final String	JPEG2000	= "image/jp2";
	public static final String	BMP			= "image/bmp";
	public static final String	TIFF		= "image/tiff";
	public static final String	PNG			= "image/png";
    
    public static final Map<String, String> TYPES = new HashMap<String, String>();
    static
    {
        TYPES.put(JPEG, "JPEG");
        TYPES.put(JPEG2000, "JPEG2000");
        TYPES.put(BMP, "BMP");
        TYPES.put(TIFF, "TIFF");
        TYPES.put(PNG, "PNG");
    }
    
    private String      mimeType;

	private File		dicomFile;
	private String		sopClassUid;

	private double		windowCenter;
	private double		windowWidth;
	private boolean		lossy;
	private String		modality;
	
	private int 		dstWidth;
	private int			dstHeight;
	private double[]	region;
	
	private int			frameNumber;
	
	private Logger		logger;

	/**
	 * @param dicomFile
	 *        The DICOM file to convert.
	 * @param sopClassUID
	 *        The SOP Class UID of the file to convert.
	 */
	public ImageConverter(File dicomFile, String sopClassUID, String modality)
	{
		this.dicomFile		= dicomFile;
		this.sopClassUid	= sopClassUID;
		this.lossy			= true;
		this.modality		= modality;
		this.dstWidth		= -1;
		this.dstHeight		= -1;
		this.windowCenter	= Integer.MIN_VALUE;
		this.windowWidth	= Integer.MIN_VALUE;
		this.frameNumber	= 0;
		
		this.logger			= Logger.getLogger(AbstractServlet.class);
	}

	/**
	 * Sets the window center and window width.
	 * 
	 * @param windowCenter
	 *        The preset window center (Brightness).
	 * @param windowWidth
	 *        The preset window width (Contrast).
	 */
	public void setWindowCenterAndWidth(double windowCenter, double windowWidth)
	{
		this.windowCenter	= windowCenter;
		this.windowWidth	= windowWidth;
	}
	
	/**
	 * Sets the WADO request.
	 * 
	 * @param request
	 *        The WADO request object.
	 *        
	 * @throws WADOException
	 *         thrown if there are any syntax errors in the request.
	 */
	public void setRequest(WadoRequest request) throws WADOException
	{
		if (request != null)
		{
			// test different properties
            this.mimeType = WADORequestHandler.getContentType(request);
            
			if (request.getImageQuality() == 100)
			{
				this.setLossy(false);				
			}
			if (request.getColumns() > 0)
			{
				this.dstWidth = request.getColumns();
			}
			if (request.getRows() > 0)
			{
				this.dstHeight = request.getRows();
			}
			if (request.getRegion() != null)
			{
				this.region = request.getRegion();
			}
			if (request.getWindowCenter() > 0 && request.getWindowWidth() > 0)
			{
				setWindowCenterAndWidth(request.getWindowCenter(), request.getWindowWidth());
			}
			if (request.getFrameNumber() > 0)
			{
				this.frameNumber = request.getFrameNumber() - 1;
			}
			// validate size
			if ((this.dstWidth < 0 && this.dstHeight > 0)
					|| (this.dstWidth > 0 && this.dstHeight < 0))
			{
				// both should have been set
				throw new WADOException(
						ErrorMessages.INVALID_ARGUMENT_ERROR
								+ "both the columns and rows should be set if one of them is.",
						HttpServletResponse.SC_BAD_REQUEST);
			}
			// validate window center and width
			if ((this.windowCenter < 0 && this.windowWidth > 0)
					|| (this.windowCenter > 0 && this.windowWidth < 0))
			{
				// both should have been set
				throw new WADOException(
						ErrorMessages.INVALID_ARGUMENT_ERROR
								+ "both the window width and center should be set if one of them is.",
						HttpServletResponse.SC_BAD_REQUEST);
			}
			// validate region
			if (!checkRegion(this.region))
			{
				throw new WADOException(
						ErrorMessages.INVALID_ARGUMENT_ERROR
								+ "the region specified is not valid.",
						HttpServletResponse.SC_BAD_REQUEST);
			}
		}
	}
	
	/**
	 * Gets the DICOM file to convert.
	 * 
	 * @return Returns the DICOM file to convert.
	 */
	public File getDicomFile()
	{
		return this.dicomFile;
	}
	
	/**
	 * Gets the SOP Class UID of the image to convert.
	 * 
	 * @return Returns the SOP Class UID of the image to convert.
	 */
	public String getSOPClassUID()
	{
		return this.sopClassUid;
	}
	
	/**
	 * Gets the frame number of the image to convert.
	 * 
	 * @return Returns the frame number of the image to convert.
	 */
	public int getFrameNumber()
	{
		return this.frameNumber;
	}
	
	/**
	 * Gets the requested width of the image to convert.
	 * 
	 * @return Returns the requested width of the image to convert.
	 */
	public int getImageWidth()
	{
		return this.dstWidth;
	}
	
	/**
	 * Gets the requested height of the image to convert.
	 * 
	 * @return Returns the requested height of the image to convert.
	 */
	public int getImageHeight()
	{
		return this.dstHeight;
	}
	
	/**
	 * Gets the window width.
	 * 
	 * @return Returns the window width.
	 */
	public double getWindowWidth()
	{
		return this.windowWidth;
	}
	
	/**
	 * Gets the window center.
	 * 
	 * @return Returns the window center.
	 */
	public double getWindowCenter()
	{
		return this.windowCenter;
	}
	
	/**
	 * Gets the requested region of the image to convert.
	 * 
	 * @return Returns the requested region of the image to convert.
	 */
	public double[] getClippedRegion()
	{
		return this.region;
	}
	
	/**
	 * Sends a <code>BufferedImage</code> to the supplied <code>OutputStream</code>.
	 * The stream may point to a file, a servlet output stream, or any other viable
	 * output stream. This method will encode the <code>BufferedImage</code> with the 
	 * given MIME type.
	 * 
	 * @param out
	 *        The <code>OutputStream</code>.
	 *        
	 * @param image
	 *        The <code>BufferedImage</code>.
	 *        
	 * @param mimeType
	 *        The MIME type used to encode the image.
	 *        
	 * @throws IOException
	 *         thrown if there is an error writing to the output stream.
	 */
	public void writeToStream(OutputStream out, BufferedImage image, String mimeType)
			throws IOException
	{
		Iterator writers = ImageIO.getImageWritersByMIMEType(mimeType);
		
		if (writers != null && writers.hasNext())
		{
			ImageWriter writer = (ImageWriter)writers.next();
            ImageWriteParam myParam;
            
            if(this.mimeType.equals(JPEG2000)){
            
	            if(isLossy()){
		            myParam = ModalityJ2KParams.getParam(modality);
	            }else{
	            	//the default (lossless) param
	            	myParam = ModalityJ2KParams.getParam("");
	            }
	            
	            if(myParam == null){
	            	logger.error("Could not get ImageWriteParam");
	            }
	            
	            J2KImageWriteParam j2kparam = (J2KImageWriteParam)myParam;
	            this.logger.debug("Writing " + (j2kparam.getLossless() ? "lossless" : "lossy") + 
	            		" JPEG2000 image at " + j2kparam.getEncodingRate() + " bpp");
            }else{
            	this.logger.debug("Writing non J2K image with MIME type \"" + this.mimeType + " and writer " + writer.getClass());
            	myParam = writer.getDefaultWriteParam();
            }
            
			if (writer != null)
			{
				ImageOutputStream iOut = 
					ImageIO.createImageOutputStream(new BufferedOutputStream(out, 4096));
				
                writer.setOutput(iOut);
                
				try
				{
					long start_time = System.currentTimeMillis();
                    
                    ParameterBlockJAI pb = new ParameterBlockJAI("ImageWrite", "rendered");
                    
                    pb.addSource(image);
                    pb.setParameter("Output", iOut);
                    pb.setParameter("Format", TYPES.get(mimeType));
                    pb.setParameter("WriteParam", myParam);
                    
                    pb.setParameter("Writer", writer);
                    
                    JAI.create("ImageWrite", pb);
					this.logger.info(this.getClass().getName() + ".writeToStream()" +
					        "Wrote image in " + (System.currentTimeMillis() - start_time) +
					        "ms");
				}
				catch (Throwable t)
				{
					Logger logger = Logger.getLogger(AbstractServlet.class);
					logger.error(t.getMessage(), t);
					
					ServerProperties.runGarbageCollection(false);
				}
				
				try
				{
					iOut.flush();
					iOut.close();
				}
				catch (Throwable t)
				{
					Logger logger = Logger.getLogger(AbstractServlet.class);
					logger.error(t.getMessage(), t);
					
					ServerProperties.runGarbageCollection(false);
				}
				
				try
				{
					writer.dispose();
				}
				catch (Throwable t)
				{
					Logger logger = Logger.getLogger(AbstractServlet.class);
					logger.error(t.getMessage(), t);
					
					ServerProperties.runGarbageCollection(false);
				}
				
				return;
			}
		}
		throw new IOException(ErrorMessages.FORMAT_WRITER_ERROR + mimeType);
	}

	/**
	 * Checks the supplied region to make certain that it passes the WADO
	 * requirements.
	 * 
	 * @param region
	 *        The region to test.
	 * 
	 * @return Returns <code>true</code> if the region passes the WADO
	 *         requirements.
	 */
	public static final boolean checkRegion(double[] region)
	{
		if (region == null) return true; // the region may be null
		if (region.length != 4)
			return false;

		if (region[0] < 0.0 || region[0] >= 1.0)
			return false;

		if (region[1] < 0.0 || region[1] >= 1.0)
			return false;

		if (region[2] <= 0.0 || region[2] > 1.0)
			return false;

		if (region[3] <= 0.0 || region[3] > 1.0)
			return false;

		if (region[0] >= region[2])
			return false;

		if (region[1] >= region[3])
			return false;

		return true;
	}

    /**
     * Gets the MIME Type.
     *
     * @return Returns the MIME Type.
     */
    public String getMimeType()
    {
        return this.mimeType;
    }

    /**
     * Sets the MIME Type.
     *
     * @param mimeType The MIME Type to set.
     */
    public void setMimeType(String mimeType)
    {
        this.mimeType = mimeType;
    }

	public boolean isLossy() {
		return lossy;
	}

	public void setLossy(boolean lossy) {
		this.lossy = lossy;
	}
}
