/* ****************************************************************************
 * Copyright (C) 2007 Hx Technologies, Inc.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * version 2 as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * $Id: HTTPResponseService.java,v 1.2 2007/11/16 16:05:42 kpearce Exp $
 * Last Revised By   : $Author: kpearce $
 * Last Checked In   : $Date: 2007/11/16 16:05:42 $
 * Last Version      : $Revision: 1.2 $
 *
 * Original Author   : Rafael Chargel
 * Origin            : Hx Technologies Inc.
 *
 *****************************************************************************/
package com.hxti.xebra.com;

import java.awt.RenderingHints;
import java.awt.image.BufferedImage;

import java.io.File;
import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;

import javax.servlet.http.HttpServletResponse;

import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.apache.log4j.Logger;

import com.hxti.edge.pacs.data.HxTiObject;
import com.hxti.edge.pacs.data.Instance;
import com.hxti.xebra.com.wado.WADORequestHandler;
import com.hxti.xebra.util.ImageConverter;
import com.hxti.xebra.util.ImageUtilties;
import com.hxti.xebra.util.ServerProperties;

import com.hxti.dicom.exception.WADOException;
import com.hxti.dicom.util.DicomToXMLConverter;
import com.hxti.dicom.util.ErrorMessages;


/**
 * This is a service used to make HTTP responses back to the Xebra client.  All of the methods 
 * of this service send the <code>HttpServletResposne</code>.  All of these methods are 
 * thread-safe, and any threaded requests to these methods should consider the server's response 
 * time.
 * 
 * <p>
 * For an overview on the Hypertext Transfer Protocol (HTTP) please see the documentation available
 * on the <a target="_blank" href="http://www.w3.org/Protocols/">World Wide Web Consortium's (W3C) 
 * web site</a>.
 * </p>
 * 
 * @author Rafael Chargel
 * @version $Revision: 1.2 $
 */
public final class HTTPResponseService
{	
	private static final Logger LOGGER = Logger.getLogger(AbstractServlet.class);

	/**
	 * Cannot be instantiated.
	 */
	private HTTPResponseService()
	{
		super();
	}
	
	/**
	 * Outputs a DICOM file through the servlet output stream.
	 * 
	 * @param response
	 *        The <code>HttpServletResponse</code> object that contains the
	 *        response the servlet returns to the client.
	 *        
	 * @param adaptor 
	 *        The <code>WADORequestAdaptor</code> processing the request.
	 *        
	 * @throws WADOException
	 *         thrown if there is an error before the header is sent.
	 */
	public static void outputDicomObject(HttpServletResponse response, 
			WADORequestHandler adaptor) throws WADOException
	{
		// output file directly to output stream
		LOGGER.info("WADO Response (DICOM)");
		
		HxTiObject object = null;
		try
		{
			object = adaptor.getRequestedObject();
			if (object == null)
			{
				LOGGER.error(HTTPResponseService.class.getName() + ".outputDicomObject(): "
						+ ErrorMessages.FILE_NOT_FOUND_ERROR);
				throw new Exception(ErrorMessages.FILE_NOT_FOUND_ERROR);
			}
		}
		catch (Throwable t)
		{
			LOGGER.error(HTTPResponseService.class.getName() + ".outputDicomObject()",t);
			throw new WADOException(t, HttpServletResponse.SC_NOT_FOUND);
		}
		
		/*
		 * Now that we have the object we need to see if it is an image 
		 * or a report
		 */
		File file = ((Instance)object).getImageFile();
		
		// we have the file, is it really DICOM and does it exist?
		if (!file.exists() || file.isDirectory())
		{
			// the file doesn't exist, or it's a directory
			
			LOGGER.error(HTTPResponseService.class.getName() + ".outputDicomObject(): "
					+ ErrorMessages.FILE_NOT_FOUND_ERROR);
			
			throw new WADOException(ErrorMessages.FILE_NOT_FOUND_ERROR, 
					HttpServletResponse.SC_NOT_FOUND);
		}
		if (!file.getName().toLowerCase().endsWith(adaptor.getContentExtension()))
		{
			// not a real DICOM file.
			LOGGER.error(HTTPResponseService.class.getName() + ".outputDicomObject(): "
					+ ErrorMessages.INVALID_FORMAT_ERROR + "the file is not a DICOM file.");
			
			throw new WADOException(ErrorMessages.INVALID_FORMAT_ERROR + 
					"the file is not a DICOM file.", 
					HttpServletResponse.SC_BAD_REQUEST);
		}
		
		ServerProperties sp = ServerProperties.getSingletonInstance();
		
		BufferedInputStream  in  = null;
		BufferedOutputStream out = null;
		
		try
		{
			in = new BufferedInputStream(new FileInputStream(file), 
					sp.getDefaultDataBuffer());
		}
		catch (FileNotFoundException exc)
		{
			LOGGER.error(HTTPResponseService.class.getName() + ".outputDicomObject()", exc);
			throw new WADOException(exc, HttpServletResponse.SC_NOT_FOUND);
		}
		catch (Throwable t)
		{
			LOGGER.error(HTTPResponseService.class.getName() + ".outputDicomObject()", t);
			throw new WADOException(t, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
		}
		
		// output response.
		response.setContentType(adaptor.getContentType());
		response.setContentLength((int)file.length());
		response.setHeader("Content-disposition", 
				"inline; filename=" + file.getName());
		
		try
		{
			out = new BufferedOutputStream(response.getOutputStream(), sp.getDefaultDataBuffer());
			
			byte[] buffer = new byte[sp.getDefaultDataBuffer()];
			int read = -1;
			
			while ((read = in.read(buffer)) != -1)
			{
				out.write(buffer, 0, read);
				out.flush();
			}
		}
		catch (Throwable t)
		{
			// too late to output anything
			LOGGER.error(HTTPResponseService.class.getName() + ".outputDicomObject()", t);
			return;
		}
		
		// close connections
		try
		{
			if (out != null) out.close();
			if (in != null) in.close();
		}
		catch (Throwable t)
		{
			// too late to output anything
			LOGGER.error(HTTPResponseService.class.getName() + ".outputDicomObject()", t);
			return;
		}
	}
	
	/**
	 * Outputs a XML file through the servlet output stream.
	 * 
	 * @param response The 
	 *        The <code>HttpServletResponse</code> object that contains the
	 *        response the servlet returns to the client.
	 *        
	 * @param adaptor 
	 *        The <code>WADORequestAdaptor</code> processing the request.
	 *        
	 * @throws WADOException
	 *         thrown if there is an error before the header is sent.
	 */
	public static void outputXMLObject(HttpServletResponse response, 
			WADORequestHandler adaptor) throws WADOException
	{
		LOGGER.info("WADO Response (XML)");
		
		// output file directly to output stream
		HxTiObject object = null;
		try
		{
			object = adaptor.getRequestedObject();
			if (object == null)
			{
				LOGGER.error(HTTPResponseService.class.getName() + ".outputXMLObject(): "
						+ ErrorMessages.FILE_NOT_FOUND_ERROR);
				
				throw new Exception(ErrorMessages.FILE_NOT_FOUND_ERROR);
			}
		}
		catch (Throwable t)
		{
			LOGGER.error(HTTPResponseService.class.getName() + ".outputXMLObject()", t);
			throw new WADOException(t, HttpServletResponse.SC_NOT_FOUND);
		}
		
		/*
		 * Now that we have the object we need to see if it is an image 
		 * or a report
		 */
		File file = ((Instance)object).getImageFile();
		
		// we have the file, does it exist?
		if (!file.exists() || file.isDirectory())
		{
			// the file doesn't exist, or it's a directory
			
			LOGGER.error(HTTPResponseService.class.getName() + ".outputXMLObject(): "
					+ ErrorMessages.FILE_NOT_FOUND_ERROR);
			
			throw new WADOException(ErrorMessages.FILE_NOT_FOUND_ERROR, 
					HttpServletResponse.SC_NOT_FOUND);
		}
		
		if (!file.getName().toLowerCase().endsWith(adaptor.getContentExtension())
				&& !file.getName().toLowerCase().endsWith(".dcm")
				&& !file.getName().toLowerCase().endsWith(".htm")
				&& !file.getName().toLowerCase().endsWith(".html"))
		{
			// not a real DICOM file.
			LOGGER.error(HTTPResponseService.class.getName() + ".outputXMLObject(): "
					+ ErrorMessages.INVALID_FORMAT_ERROR + "the file is not a XML or DICOM file.");
			
			throw new WADOException(ErrorMessages.INVALID_FORMAT_ERROR + 
					"the file is not a XML or DICOM file.", 
					HttpServletResponse.SC_BAD_REQUEST);
		}
		
		ServerProperties sp = ServerProperties.getSingletonInstance();
				
		// if this is an XML file, output it directly
		if (file.getName().endsWith(adaptor.getContentExtension()))
		{
			BufferedInputStream  in  = null;
			BufferedOutputStream out = null;
			try
			{
				in = new BufferedInputStream(new FileInputStream(file), 
						sp.getDefaultDataBuffer());
			}
			catch (FileNotFoundException exc)
			{
				LOGGER.error(HTTPResponseService.class.getName() + ".outputXMLObject()", exc);
				throw new WADOException(exc, HttpServletResponse.SC_NOT_FOUND);
			}
			catch (Throwable t)
			{
				LOGGER.error(HTTPResponseService.class.getName() + ".outputXMLObject()", t);
				throw new WADOException(t, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
			}
			
			response.setContentType(adaptor.getContentType());
			response.setContentLength((int)file.length());
			response.setHeader("Content-disposition", 
					"inline; filename=" + file.getName());
			
			try
			{
				out = new BufferedOutputStream(response.getOutputStream(), sp.getDefaultDataBuffer());
				
				byte[] buffer = new byte[sp.getDefaultDataBuffer()];
				int read = -1;
				
				while ((read = in.read(buffer)) != -1)
				{
					out.write(buffer, 0, read);
					out.flush();
				}
			}
			catch (Throwable t)
			{
				// too late to output anything
				LOGGER.error(HTTPResponseService.class.getName() + ".outputXMLObject()", t);
				return;
			}
			
			// close connections
			try
			{
				if (out != null) out.close();
				if (in != null) in.close();
			}
			catch (Throwable t)
			{
				// too late to output anything
				LOGGER.error(HTTPResponseService.class.getName() + ".outputXMLObject()", t);
				return;
			}
		}
		
		// the file is actually a DICOM file, convert the file, then output it
		DicomToXMLConverter converter = null;
		try
		{
			converter = new DicomToXMLConverter(file);
		}
		catch (Throwable t)
		{
			LOGGER.error(HTTPResponseService.class.getName() + ".outputXMLObject()", t);
			// still haven't sent the header
			throw new WADOException(t, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
		}
		
		try
		{
			AbstractServlet.sendResponse(converter.getDocument(), response);
		}
		catch (Throwable t)
		{
			// to late to do anything about it
			LOGGER.error(HTTPResponseService.class.getName() + ".outputXMLObject()", t);
			return;
		}
	}
	
	/**
	 * Outputs a HTML file through the servlet output stream.
	 * 
	 * @param response The 
	 *        The <code>HttpServletResponse</code> object that contains the
	 *        response the servlet returns to the client.
	 *        
	 * @param adaptor 
	 *        The <code>WADORequestAdaptor</code> processing the request.
	 *        
	 * @throws WADOException
	 *         thrown if there is an error before the header is sent.
	 */
	public static void outputHTMLObject(HttpServletResponse response, 
			WADORequestHandler adaptor) throws WADOException
	{
		LOGGER.info("WADO Response (HTML)");
		
		// output file directly to output stream
		HxTiObject object = null;
		try
		{
			object = adaptor.getRequestedObject();
			if (object == null)
			{
				LOGGER.error(HTTPResponseService.class.getName() + ".outputHTMLObject(): "
						+ ErrorMessages.FILE_NOT_FOUND_ERROR);
				
				throw new Exception(ErrorMessages.FILE_NOT_FOUND_ERROR);
			}
		}
		catch (Throwable t)
		{
			LOGGER.error(HTTPResponseService.class.getName() + ".outputHTMLObject()", t);
			throw new WADOException(t, HttpServletResponse.SC_NOT_FOUND);
		}
		
		/*
		 * Now that we have the object we need to see if it is an image 
		 * or a report
		 */
		File file = ((Instance)object).getImageFile();
		
		// we have the file, does it exist?
		if (!file.exists() || file.isDirectory())
		{
			// the file doesn't exist, or it's a directory

			LOGGER.error(HTTPResponseService.class.getName() + ".outputHTMLObject(): "
					+ ErrorMessages.FILE_NOT_FOUND_ERROR);
			
			throw new WADOException(ErrorMessages.FILE_NOT_FOUND_ERROR, 
					HttpServletResponse.SC_NOT_FOUND);
		}
		
		if (!file.getName().toLowerCase().endsWith(adaptor.getContentExtension())
				&& !file.getName().toLowerCase().endsWith(".dcm")
				&& !file.getName().toLowerCase().endsWith(".html"))
		{
			// not a real DICOM or HTML file.
			LOGGER.error(HTTPResponseService.class.getName() + ".outputHTMLObject(): "
					+ ErrorMessages.INVALID_FORMAT_ERROR + "the file is not a HTML or DICOM file.");
			
			throw new WADOException(ErrorMessages.INVALID_FORMAT_ERROR + 
					"the file is not a HTML or DICOM file.", 
					HttpServletResponse.SC_BAD_REQUEST);
		}
		
		ServerProperties sp = ServerProperties.getSingletonInstance();
				
		// if this is an XML file, output it directly
		if (file.getName().endsWith(adaptor.getContentExtension()))
		{
			BufferedInputStream  in  = null;
			BufferedOutputStream out = null;
			try
			{
				in = new BufferedInputStream(new FileInputStream(file), 
						sp.getDefaultDataBuffer());
			}
			catch (FileNotFoundException exc)
			{
				LOGGER.error(HTTPResponseService.class.getName() + ".outputHTMLObject()", exc);
				throw new WADOException(exc, HttpServletResponse.SC_NOT_FOUND);
			}
			catch (Throwable t)
			{
				LOGGER.error(HTTPResponseService.class.getName() + ".outputHTMLObject()", t);
				throw new WADOException(t, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
			}
			
			response.setContentType(adaptor.getContentType());
			response.setContentLength((int)file.length());
			response.setHeader("Content-disposition", 
					"inline; filename=" + file.getName());
			
			try
			{
				out = new BufferedOutputStream(response.getOutputStream(), sp.getDefaultDataBuffer());
				
				byte[] buffer = new byte[sp.getDefaultDataBuffer()];
				int read = -1;
				
				while ((read = in.read(buffer)) != -1)
				{
					out.write(buffer, 0, read);
					out.flush();
				}
			}
			catch (Throwable t)
			{
				// too late to output anything
				LOGGER.error(HTTPResponseService.class.getName() + ".outputHTMLObject()", t);
				return;
			}
			
			// close connections
			try
			{
				if (out != null) out.close();
				if (in != null) in.close();
			}
			catch (Throwable t)
			{
				// too late to output anything
				LOGGER.error(HTTPResponseService.class.getName() + ".outputHTMLObject()", t);
				return;
			}
		}
		
		// the file is actually a DICOM file, convert the file, then output it
		DicomToXMLConverter converter = null;
		try
		{
			converter = new DicomToXMLConverter(file);
		}
		catch (Throwable t)
		{
			LOGGER.error(HTTPResponseService.class.getName() + ".outputHTMLObject()", t);
			// still haven't sent the header
			throw new WADOException(t, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
		}
		
		try
		{
			// generate a result
			response.setContentType(adaptor.getContentType());
			response.setHeader("Content-disposition", 
					"inline; filename=response.html");
			
			OutputStream out = response.getOutputStream();
			
            Source domSource = new DOMSource(converter.getDocument());
            Source xslSource = new StreamSource(HTTPResponseService.class.getResourceAsStream("/xsl_files/html.xsl"));
            Result result = new StreamResult(out);
            
            Transformer trans = TransformerFactory.newInstance().newTransformer(xslSource);
            
            trans.transform(domSource, result);
			out.flush();
			out.close();
		}
		catch (Throwable t)
		{
			// to late to do anything about it
			LOGGER.error(HTTPResponseService.class.getName() + ".outputHTMLObject()", t);
			return;
		}
	}
	
	/**
	 * Outputs a text file through the servlet output stream.
	 * 
	 * @param response The 
	 *        The <code>HttpServletResponse</code> object that contains the
	 *        response the servlet returns to the client.
	 *        
	 * @param adaptor 
	 *        The <code>WADORequestAdaptor</code> processing the request.
	 *        
	 * @throws WADOException
	 *         thrown if there is an error before the header is sent.
	 */
	public static void outputTextObject(HttpServletResponse response, 
			WADORequestHandler adaptor) throws WADOException
	{
		LOGGER.info("WADO Response (TEXT)");
		
		// output file directly to output stream
		HxTiObject object = null;
		try
		{
			object = adaptor.getRequestedObject();
			if (object == null)
			{
				LOGGER.error(HTTPResponseService.class.getName() + ".outputTextObject(): "
						+ ErrorMessages.FILE_NOT_FOUND_ERROR);
				
				throw new Exception(ErrorMessages.FILE_NOT_FOUND_ERROR);
			}
		}
		catch (Throwable t)
		{
			LOGGER.error(HTTPResponseService.class.getName() + ".outputTextObject()", t);
			throw new WADOException(t, HttpServletResponse.SC_NOT_FOUND);
		}
		
		/*
		 * Now that we have the object we need to see if it is an image 
		 * or a report
		 */
		File file = ((Instance)object).getImageFile();
		
		// we have the file, does it exist?
		if (!file.exists() || file.isDirectory())
		{
			// the file doesn't exist, or it's a directory

			LOGGER.error(HTTPResponseService.class.getName() + ".outputTextObject(): "
					+ ErrorMessages.FILE_NOT_FOUND_ERROR);
			
			throw new WADOException(ErrorMessages.FILE_NOT_FOUND_ERROR, 
					HttpServletResponse.SC_NOT_FOUND);
		}
		
		if (!file.getName().toLowerCase().endsWith(adaptor.getContentExtension()))
		{
			// not a real text file.
			LOGGER.error(HTTPResponseService.class.getName() + ".outputTextObject(): "
					+ ErrorMessages.INVALID_FORMAT_ERROR + "the file is not a TEXT file.");
			
			throw new WADOException(ErrorMessages.INVALID_FORMAT_ERROR + 
					"the file is not a TEXT file.", 
					HttpServletResponse.SC_BAD_REQUEST);
		}
		
		ServerProperties ap = ServerProperties.getSingletonInstance();
				
		// this is a text file, output it directly
		BufferedInputStream  in  = null;
		BufferedOutputStream out = null;
		try
		{
			in = new BufferedInputStream(new FileInputStream(file), 
					ap.getDefaultDataBuffer());
		}
		catch (FileNotFoundException exc)
		{
			LOGGER.error(HTTPResponseService.class.getName() + ".outputTextObject()", exc);
			throw new WADOException(exc, HttpServletResponse.SC_NOT_FOUND);
		}
		catch (Throwable t)
		{
			LOGGER.error(HTTPResponseService.class.getName() + ".outputTextObject()", t);
			throw new WADOException(t, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
		}
		
		response.setContentType(adaptor.getContentType());
		response.setContentLength((int)file.length());
		response.setHeader("Content-disposition", 
				"inline; filename=" + file.getName());
		
		try
		{
			out = new BufferedOutputStream(response.getOutputStream(), ap.getDefaultDataBuffer());
			
			byte[] buffer = new byte[ap.getDefaultDataBuffer()];
			int read = -1;
			
			while ((read = in.read(buffer)) != -1)
			{
				out.write(buffer, 0, read);
				out.flush();
			}
		}
		catch (Throwable t)
		{
			// too late to output anything
			LOGGER.error(HTTPResponseService.class.getName() + ".outputTextObject()", t);
			return;
		}
		
		// close connections
		try
		{
			if (out != null) out.close();
			if (in != null) in.close();
		}
		catch (Throwable t)
		{
			// too late to output anything
			LOGGER.error(HTTPResponseService.class.getName() + ".outputTextObject()", t);
			return;
		}
	}
	
	/**
	 * Outputs an image file through the servlet output stream.
	 * 
	 * @param response The 
	 *        The <code>HttpServletResponse</code> object that contains the
	 *        response the servlet returns to the client.
	 *        
	 * @param adaptor 
	 *        The <code>WADORequestAdaptor</code> processing the request.
	 *        
	 * @throws WADOException
	 *         thrown if there is an error before the header is sent.
	 */
	public static void outputImageObject(HttpServletResponse response, 
			WADORequestHandler adaptor) throws WADOException
	{
		LOGGER.info("WADO Response (Image)");
		
		// must convert the image before outputting it to the file stream
		Instance image = null;
		try
		{
			LOGGER.info(HTTPResponseService.class.getName() + 
					".outputImageObject(): Retrieving the image.");
			
			image = adaptor.getImage();
			if (image == null)
			{
				LOGGER.error(HTTPResponseService.class.getName() + ".outputImageObject(): "
						+ ErrorMessages.FILE_NOT_FOUND_ERROR);
				
				throw new Exception(ErrorMessages.FILE_NOT_FOUND_ERROR);
			}
		}
		catch (Throwable t)
		{
			LOGGER.error(HTTPResponseService.class.getName() + ".outputImageObject()", t);
			throw new WADOException(t, HttpServletResponse.SC_NOT_FOUND);
		}
        
        boolean headerSent = false;
        
        // check for JPEG File
        if (adaptor.canReadWriteFromCache())
        {
        	File jpeg = null;
        	if(image.getJpegFileLocation() != null &&
        			adaptor.getWadoRequest().getImageQuality() < 100){
        		jpeg = new File(image.getJpegFileLocation());
        	}else if(image.getLosslessJpegFileLocation() != null &&
        			adaptor.getWadoRequest().getImageQuality() == 100){
        		jpeg = new File(image.getLosslessJpegFileLocation());
        	}
        	
            if (jpeg != null)
            {
                LOGGER.info("Attempting to read file from cache: " + jpeg.getAbsolutePath());
                
                if (jpeg.exists() && jpeg.length() > 0)
                {
                    LOGGER.info(HTTPResponseService.class.getName() + ".outputImageObject(): Sending image from JPEG Cache");
                    // write to browser
                    response.setContentType(adaptor.getContentType());
                    response.setHeader("Content-disposition", 
                            "inline; filename=image" + adaptor.getContentExtension());
                    headerSent = true;
                    try
                    {
                        BufferedOutputStream out = new BufferedOutputStream(response.getOutputStream(),
                                ServerProperties.getSingletonInstance().getDefaultDataBuffer());
                        
                        BufferedInputStream in = new BufferedInputStream(new FileInputStream(jpeg),
                                ServerProperties.getSingletonInstance().getDefaultDataBuffer());
                        
                        byte[] buffer = new byte[ServerProperties.getSingletonInstance().getDefaultDataBuffer()];
                        int len = -1;
                        
                        while ((len = in.read(buffer)) != -1)
                        {
                            out.write(buffer, 0, len);
                            out.flush();
                        }
                        out.close();
                        in.close();
                        
                        LOGGER.info("Finished writing image.");
                        return;
                    }
                    catch (IOException exc)
                    {
                        LOGGER.error(HTTPResponseService.class.getName() + ".outputImageObject()", exc);
                    }
                }
                else
                {
                    LOGGER.debug("File does not exist or filesize = 0");
                }
            }
            else
            {
                LOGGER.debug("The JPEG File Location is not set");
            }
        }
        
        LOGGER.info(HTTPResponseService.class.getName() + 
            ".outputImageObject(): Getting image from file.");
		
		File file = image.getImageFile();
		
		// we have the file, does it exist?
		if (!file.exists() || file.isDirectory())
		{
			// the file doesn't exist, or it's a directory

			LOGGER.error(HTTPResponseService.class.getName() + ".outputImageObject(): "
					+ ErrorMessages.FILE_NOT_FOUND_ERROR);
		
			throw new WADOException(ErrorMessages.FILE_NOT_FOUND_ERROR, 
					HttpServletResponse.SC_NOT_FOUND);
		}
		
		if (!file.getName().toLowerCase().endsWith(".dcm"))
		{
			// not a real dicom file

			LOGGER.error(HTTPResponseService.class.getName() + ".outputImageObject(): "
					+ ErrorMessages.INVALID_FORMAT_ERROR + "the file is not a DICOM file.");
		
			throw new WADOException(ErrorMessages.INVALID_FORMAT_ERROR + 
					"the file is not a DICOM file.", 
					HttpServletResponse.SC_BAD_REQUEST);
		}
		
		/*
		 * This is the hard part, we must now convert the DICOM file into a usable
		 * image format, such as JPEG or JPEG2000
		 */
		
		// start with an image converter
		ImageConverter	conv = new ImageConverter(file, image.getSopClassUid(), 
				adaptor.getImageModality());
		conv.setRequest(adaptor.getWadoRequest());
		
		// get the image utilities object
		ImageUtilties	util = new ImageUtilties();
		util.setImageConverter(conv);
		
		RenderingHints hints = new RenderingHints(RenderingHints.KEY_RENDERING,
				RenderingHints.VALUE_RENDER_QUALITY);
		
		hints.add(new RenderingHints(RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_OFF));
		
		hints.add(new RenderingHints(RenderingHints.KEY_INTERPOLATION, 
				RenderingHints.VALUE_INTERPOLATION_BILINEAR));
		
		util.setRenderingHints(hints);
		
		// get the image
		BufferedImage bufImage = null;
		try
		{
            bufImage = util.getRenderedImage();
			if (bufImage == null)
			{
				throw new Exception(ErrorMessages.IO_STREAM_ERROR 
						+ "could not generate renderable image.");
			}
		}
		catch (Throwable t)
		{
			LOGGER.error(HTTPResponseService.class.getName() + ".outputImageObject()", t);
			throw new WADOException(t, HttpServletResponse.SC_INTERNAL_SERVER_ERROR);
		}
		
		try
		{
			// write to browser
            if (!headerSent)
            {
    			response.setContentType(adaptor.getContentType());
    			response.setHeader("Content-disposition", 
    					"inline; filename=image" + adaptor.getContentExtension());
            }
			BufferedOutputStream out = new BufferedOutputStream(response.getOutputStream(),
					ServerProperties.getSingletonInstance().getDefaultDataBuffer());
			
			conv.writeToStream(out, bufImage, adaptor.getContentType());
            
            // see if we can save the file to JPEG 2000 format
            if (adaptor.canReadWriteFromCache())
            {   
                File jpeg = new File(ServerProperties.getSingletonInstance().getJpegRootDirectory());
                
                jpeg = new File(jpeg, image.getStudyInstanceUid());
                if(adaptor.getWadoRequest().getImageQuality() <= 75){
                    jpeg = new File(jpeg, image.getSOPInstanceUid() + ".jp2");
                }else if(adaptor.getWadoRequest().getImageQuality() > 75){
                    jpeg = new File(jpeg, image.getSOPInstanceUid() + 
                    		"-lossless.jp2");
                }else{
                	jpeg = null;
                }

                if(jpeg != null){
	                if(jpeg.getName().contains("lossless")){
	                	image.setLosslessJpegFileLocation(jpeg.getAbsolutePath());
	                }else{
	                	image.setJpegFileLocation(jpeg.getAbsolutePath());
	                }
	                
	                adaptor.persistImage(image);
	                
	                if (!jpeg.exists())
	                {
	                    jpeg.getParentFile().mkdirs();
	                    jpeg.createNewFile();
	                }
	                
	                LOGGER.info("Saving file to: " + image.getJpegFileLocation());
	                
	                out = new BufferedOutputStream(new FileOutputStream(jpeg),
	                        ServerProperties.getSingletonInstance().getDefaultDataBuffer());
	                
	                conv.writeToStream(out, bufImage, adaptor.getContentType());
                }
                
            }
            bufImage.flush();
            bufImage = null;
		}
		catch (Throwable t)
		{
			// to late to do anything about it.
			LOGGER.error(HTTPResponseService.class.getName() + ".outputImageObject()", t);
		}
		
		ServerProperties.runGarbageCollection(false);
		return;
	}
}
